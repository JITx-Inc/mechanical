#use-added-syntax(jitx)
defpackage mechanical/MountingHoles:
  import core
  import jitx
  import jitx/commands
  import maybe-utils

  import jsl/ensure
  import jsl/landpatterns with :
    prefix(SilkscreenOutline) => UNUSED#
  import jsl/geometry/basics
  import jsl/symbols/framework
  import jsl/errors

; I want to be able to support 2 types of
;   mounting hole:
; 1.  Non-plated Through-holes
; 2.  Plated Grounding Through-holes

doc: \<DOC>
TODO
<DOC>
public defstruct SilkscreenOutline :
  diam:Double with:
    ensure => ensure-positive!
  silk-width:Double with:
    ensure => ensure-positive!

doc: \<DOC>
TODO
<DOC>
public defstruct MountingHole :
  hole:Shape
  doc: \<DOC>
  Shape of copper landing for plated through-holes
  If this value is `None()`, then the hole will be
  unplated.
  <DOC>
  copper:Maybe<Shape> with:
    default => None()
  silk-outline:Maybe<SilkscreenOutline> with:
    default => None()
  sm-expand?:Maybe<Double> with:
    ensure => ensure-non-negative!
    default => None()
  paste:Maybe<Shape> with:
    default => None()
with:
  constructor => #MountingHole

doc: \<DOC>
TODO
<DOC>
public defn MountingHole (
  hole:Shape --
  copper:Shape|False = false
  silk-outline:SilkscreenOutline|False = false
  sm-expand?:Double|False = false
  paste:Shape|False = false
) : #MountingHole(hole, to-maybe(copper), to-maybe(silk-outline), to-maybe(sm-expand?), to-maybe(paste))

; TODO: default offset value; I made this up
val DEFAULT-OFFSET = 3.0

; TODO: more flexible offset?
;       maybe have separate x- and y-offsets?

; TODO : need to skip "middle" coordinates -- only edges
; should get mounting holes
; e.g. point(1,1) in a 3x3 grid should never get one?

doc: \<DOC>
TODO
<DOC>
public defn add-mounting-holes (
    get-mounting-hole:(Int, Int) -> Maybe<MountingHole> 
    board-shape:Shape --
    offset:Double = DEFAULT-OFFSET
    num-rows:Int = 2
    num-columns:Int = 2) :
  if num-rows < 2 : throw(ArgumentError("num-rows must be at least 2"))
  if num-columns < 2 : throw(ArgumentError("num-columns must be at least 2"))

  val d = dims(board-shape)
  val board = Rectangle(x(d), y(d))
  inside pcb-module :
    val w = width(board)
    val h = height(board)
    val dx = (w - (2.0 * offset)) / to-double(num-columns - 1)
    val dy = (h - (2.0 * offset)) / to-double(num-rows - 1)
    for (l in grid-locs(num-rows, num-columns, dx, dy), pos in grid-coords(num-rows, num-columns)) do :
      val [x, y] = pos
      match(get-mounting-hole(x, y)) :
        (h:One) :
          inst hole : mounting-hole(value(h))
          place(hole) at l on Top
        (otherwise) : false

doc: \<DOC>
Wrapper for jitx > 3.18 that computes board shape automatically 
<DOC>
public defn add-mounting-holes (
    get-mounting-hole:(Int, Int) -> Maybe<MountingHole> --
    offset:Double = DEFAULT-OFFSET
    num-rows:Int = 2
    num-columns:Int = 2) :
  val board-shape =
    match(get-board()) :
      (b:Board) : get-boundary(b)
      (otherwise) : throw(Exception("add-mounting-holes: board has not yet been set."))
  add-mounting-holes(get-mounting-hole, board-shape, offset = offset, num-rows = num-rows, num-columns = num-columns)

doc: \<DOC>
Requires jitx > 3.18 to compute board-shape
<DOC>
public defn add-mounting-holes (
    mounting-hole:MountingHole --
    offset:Double = DEFAULT-OFFSET
    num-rows:Int = 2
    num-columns:Int = 2) :
  within (x, y) = add-mounting-holes(offset = offset, num-rows = num-rows, num-columns = num-columns) :
    One(mounting-hole)

doc: \<DOC>
TODO
<DOC>
public defn add-mounting-holes (
    mounting-hole:MountingHole 
    board-shape:Shape --
    offset:Double = DEFAULT-OFFSET
    num-rows:Int = 2
    num-columns:Int = 2) :
  within (x, y) = add-mounting-holes(board-shape, offset = offset, num-rows = num-rows, num-columns = num-columns) :
    One(mounting-hole)

; Helper for generating a sequence of coordinates given grid dimensions
; Assumes row-major traversal, which is the default for grid-locs 
; top-left corner is (0,0)
defn grid-coords (nrows:Int, ncols:Int) -> Seq<[Int,Int]> :
  for y in 0 to ncols seq-cat :
    for x in 0 to ncols seq : [x, y]

; Mounting hole component
defn mounting-hole (mh:MountingHole) :
  pcb-component comp :
    pin-properties:
      [pin:Ref | pads:Ref ...]
      [p       | p           ]

    ; Schematic symbol
    assign-symbol(create-symbol(MHSymbol(mh)))

    ; Assign landpattern
    assign-landpattern(mounting-hole-pkg(mh))
  comp

;=========================
; Landpattern helpers
;=========================

; Add a silkscreen layer to the mounting hole landpattern
defn make-silkscreen (mh:MountingHole) :
  inside pcb-landpattern :
    match(silk-outline(mh)) :
      (silk:One) :
        layer(Silkscreen("mounting-hole", Top)) = value(silk)
      (otherwise) : false ; do nothing

; Landpattern dispatcher
defn mounting-hole-pkg (mh:MountingHole) :
  match(copper(mh):One) : plated-mounting-hole-pkg(mh)
  else : non-plated-mounting-hole-pkg(mh)

; Landpattern for non-plated mounting holes
defn non-plated-mounting-hole-pkg (mh:MountingHole) :
  ; TODO : does non-plated pad need paste?
  pcb-landpattern lp :
    val sm =
      match(sm-expand?(mh)) :
        (x:One) : expand(hole(mh), value(x))
        (otherwise) : false
    pad p : npth-pad(/hole(mh), sm) at loc(0.0, 0.0)
    make-silkscreen(mh)
  lp

; Landpattern for plated mounting holes
defn plated-mounting-hole-pkg (mh:MountingHole) :
  pcb-landpattern lp :
    val sm =
      match(sm-expand?(mh)) :
        (x:One) : expand(hole(mh), value(x))
        (otherwise) : false
    val paste =
      match(/paste(mh)) :
        (p:One) : value(p)
        (otherwise) : false
    val mh-pad = pth-pad(/hole(mh), value!(/copper(mh)), sm, paste)
    pad p : mh-pad at loc(0.0, 0.0)
    make-silkscreen(mh)
  lp

;=========================
; Symbol helpers
;=========================

; Schematic symbol for mounting holes
; If hole is plated, symbol is filled in
; TODO : is there a more idiomatic way to do this?
defn MHSymbol (mh:MountingHole) -> SymbolDefn :
  val r1 = 0.25
  val r2 = 0.5
  val shift-up = Pose(Point(0.0, r2), 0.0, false)
  new SymbolDefn :
    defmethod name (this) -> String : "MountingHole"
    defmethod build-pins (this, sn:SymbolNode) :
      add-pin(sn, Ref(`p), Point(0.0, 0.0), name = "pin-1")
    defmethod build-artwork (this, sn:SymbolNode) :
      ; radii
      if copper(mh) is One : ; plated case: circles are filled
        add-glyph(sn, shift-up * Circle(r2))
        add-glyph(sn, shift-up * Circle(r1))
      else : ; non-plated: use lines
        val arc1 = Arc(Point(0.0, 0.0), r1, 0.0, 360.0)
        val arc2 = Arc(Point(0.0, 0.0), r2, 0.0, 360.0)
        val lw = 0.05 ; symbol-line-width(mh)
        add-glyph(sn, shift-up * Polyline(lw, [arc1]))
        add-glyph(sn, shift-up * Polyline(lw, [arc2]))
    defmethod build-params (this, sn:SymbolNode) :
      false
